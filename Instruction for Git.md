q1. Первые действия для проверки верной устновки Git

Выполнить команду:

**git version**

* Должна выйти строка с версикй Git

2. Указать для Git репозиторий

Выполнить команду:

**git init**

* Git инициализирует репозиторий, прописывает путь.

3. Узнать текущее состояние репозитория

Выполнить команду

**git status**

* В норме Git показывет, что репозиторий не отслеживается (на данном этапе), что нет сохранений. Показывает актуальную ветку (master)

4. Добавить актуальную версию файла в отслеживание для Git

Выполнить команду

**git add . \название файла для отслеживания\\**

Название файла можно написать, можно выбрать с помощью клавиши Tab

Если файл текущий, то можно командой

**git add .**

* Никакие сообщения не выводятся. Но в проводнике буква U справа от названия файла меняется на А

5. Проверить еще раз статус файла, чтобы убедиться, что он принят Git в отслеживание

**git status**

* Файл добавлен в отслеживание и окрашен в зелый цвет

6. Для сохранения изменений в файле выполнить следующую команду

**git commit -m"_______"**

Где после m можно\нужно написать сообщение, которое будет выдаваться при просмотре сохраненных версий

* Изменения сохранены

7. Проверим еще раз статус файла, чтоб убедиться в сохранении изменений

**git status**

* В норме, что Git пишет, что сохранять нечего (так как последние изменения все сохранены)

8. Создадим и сохраним изменения, чтоб потом перейти к первому сохранению.

**git add .**

**git commit -m"8 пунктов"**

Необходимо также сохранять изменения клавишами (ctrl+S) или через "Файл-сохранить" ДО начала команд, что выше.

* Второй коммит сохранен

9. Чтобы просмотреть журнал версий выполняем команду

**git log**

* Показывает весь журнал коммитов

10. Чтобы перейти к нужному коммиту, сохраненному раннее используем команду

**git checkout**

Переходим к нужной версии

Еще некоторые полезные команды

Показать различие текущего файла от сохраненного (перед переключением версии файла использовать команду **git log**, чтобы увидеть количество изменений)

**git diff**

Очистить содержание терминала

**clear**

# Работа с ветками

1. Работу с ветками начинаем с команды

**git branch**

* Git покажет ветку, на которой сейчас находимся. Сейчас пока она одна и назывется master

2. Создадим новые ветки

**git branch ВЕТКАодин** (где ВЕТКАодин название новой ветки)

**git branch ВЕТКАдва**

**git branch ВЕТКАтри**

**git branch ВЕТКАчетыре**

* Созданы 4 новые ветки. Никакие сообщения об ошибках последовать не должны

3. Проверить создание всех веток

**git branch**

* Отобразятся все четыре новые ветки + master

4. Чтобы перейти на любую другую ветку:

**git checkout ВЕТКАчетыре** (где ВЕТКАчетыре название нужной ветки)

* Перешли на нужную ветку



5. Создадим этот пункт на новой ветке (ВЕТКАчетыре) и перейдем обратно в ветку MASTER (сделав коммит на ВЕТКЕчетыре)

**git checkout master**

6. Соединим 2 ветки: master и ВЕТКУчетыре.

**git merge ВЕТКАчетыре (где ВЕТКАчетыре название ветки, которую присоединяем к основной, текущей)

* Ветки соеденены. Информация с ВЕТКИчетыре появилась на ветке master. 

* **Конфликта не последовало, так как ветка master просто догнала ветку ВЕТКАчетыре по изменениям. FAST FORWARD**

7. ВЕТКУчетыре можно удалить

**git branch -d ВЕТКАчетыре**

* Ветка удалена

8. Теперь создадим конфликт, соединив 2 ветки. На ветке master создадим 9 пункт. Перейдем на ветку ВЕТКАтри и создадим 9 пункт там же. Далее при соединении веток обнаружится конфликт в 9 пункте, где приоритетом решения оставим информацию по ветке master

9. Пункт для конфликта в master

10. Конфликт решен 

11. Теперь создадим такой же конфликт, где приоритетом сделаем решение, при котором изменения остаются верными на обеих ветках.

























































11. Пункт на ВЕТКАдва для конфликта

* Изменения с обеих веток сохранены при слиянии на ветке master.

13. После решения конфликтов на ВЕТКАдва остался 11 пункт (так как сохраняли изменения у обеих).
Проверить:

**git checkout ВЕТКАдва**

14. Проверим графическое изображение веток

**git log --graph**

15. Соединим оставшуюся ветку с master без конфликта

**git merge ВЕТКАодин**

* Конфликта не последовало

16. Теперь удалим ненужные ветки

**git branch -d ВЕТКАодин**

**git branch -d ВЕТКАдва**

**git branch -d ВЕТКАтри**

* Осталась только одна ветка master

# Работа с удаленными репозиториями (GitHub)

1. Зарегистрироваться на GitHub.com, создать свой аккаунт

2. Создать локальный репозиторий (текущий) на Git

3. Создать удаленный репозиторий на GitHub. 

* открыть свой профиль - справа кнопка "New" - дать ему имя - сделать публичным - пока пропустить все доп. пункты - создать

4. Теперь необходимо подружить локальный репозиторий и удаленный. Действуем по инструкции, предложенной GitHub (1 вариант):
* **git init**
* **git add .**
* **git commit**
* **git branch -M master** (дает понять Git, какая ветка главная, и с какой ветки обмениваться информацией с удаленным репозиторием)

5. Необходимо добавить в Git ссылку на удаленный репозиторий (ссылку скопировать с GitHub)

**git remote add origin https://github.com/......./**

6. Далее отправляем информацию с локального репозитория в удаленный. Команда дает понять, что указанная ветка доступна для обмена файлами с удаленным репозиторием.

**git push -u origin master**

7. Для проверки взаимодействия удаленного и локального репозитория создадим на локальном репозитории создадим доп. информацию.

При попытке "подружить" репозитоирии раннее выскакивала ошибка. 

*error: remote origin already exists*

Помогла команда:

**git remote rm origin**

Далее сохраняем изменения, делаем git add and git commit

Смотрим, что на локальном репозитории есть изменения 

**git log**

А на удаленном этих изменений еще нет.

Далее даем команду на "толкание" файла из локального репозитория в удаленный

**git push**

8. Этот пункт делаем с удаленного репозитория, для наглядного примера команды

**git pull"

Сохраняем изменения (Commit changes). В локальном Git делаем команду **git pull**

9. Работа с Fork (запрос на копию чужого удаленного репозитория на GitHub)

Находим нужный репозиторий (ссылка), делаем Fork. Теперь на нашем удаленном репозитории есть чужой скопированный репозиторий.

Далее в локальном репозитории клонируем файл 

**git clone**

* Появится репозиторий из чужого удаленного аккаунта

Вносим изменения. Сохраняем (add and commit). Отправляем (push) измененный файл на свой удаленный репозитоиий. 

Далее мы должны отправить наш измененный репозиторий автору исходника (того, которого копировали fork)

В удаленном репозитории нажимаем след. команды:

**Pull requests**

**New Pull requests**

**Create Pull requests** (и добавляем комментарий)

* Запрос на слияние отправлен. Готово.









